// Generated by vproto - Do not modify
module vproto_test

import emily33901.vproto

[_allow_multiple_values]
enum EnumAllowingAlias {
	unknown = 0
	started = 1
	running = 2
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_new_enumallowingalias() EnumAllowingAlias {
	return .unknown
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_enumallowingalias(e EnumAllowingAlias, num u32) []byte {
	return vproto.pack_int32_field(int(e), num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_pack_enumallowingalias_packed(e []EnumAllowingAlias, num u32) []byte {
	x := array{
		data: e.data
		len: e.len
		element_size: e.element_size
		cap: e.cap
	}
	return vproto.pack_int32_field_packed(x, num)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_enumallowingalias(buf []byte, tag_wiretype vproto.WireType) ?(int, EnumAllowingAlias) {
	i, v := vproto.unpack_int32_field(buf, tag_wiretype) ?
	return i, EnumAllowingAlias(v)
}

// FOR INTERNAL USE ONLY
[inline]
fn zzz_vproto_internal_unpack_enumallowingalias_packed(buf []byte, tag_wiretype vproto.WireType) ?(int, []EnumAllowingAlias) {
	i, v := vproto.unpack_int32_field_packed(buf, tag_wiretype) ?
	return i, array{
		data: v.data
		len: v.len
		cap: v.cap
		element_size: v.element_size
	}
}

pub struct Outer_Inner {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	ival           i64
}

pub fn (o &Outer_Inner) pack() []byte {
	mut res := []byte{}
	if o.ival != i64(0) {
		ival := vproto.pack_int64_field(o.ival, 1)
		res << ival
		unsafe {ival.free()}
	}
	return res
}

pub fn outer_inner_unpack(buf []byte) ?Outer_Inner {
	mut res := zzz_vproto_internal_new_outer_inner()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			1 {
				ii, v := vproto.unpack_int64_field(cur_buf, tag_wiretype.wire_type) ?
				res.ival = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a Outer_Inner) eq(b Outer_Inner) bool {
	return true && a.ival == b.ival
}

[inline]
pub fn (a Outer_Inner) ne(b Outer_Inner) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []Outer_Inner) eq(b []Outer_Inner) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []Outer_Inner) ne(b []Outer_Inner) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_outer_inner() Outer_Inner {
	return Outer_Inner{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_outer_inner(o Outer_Inner, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_outer_inner(buf []byte, tag_wiretype vproto.WireType) ?(int, Outer_Inner) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := outer_inner_unpack(v) ?
	return i, unpacked
}

pub struct Outer {
mut:
	unknown_fields []vproto.UnknownField
pub mut:
	inner_message  []Outer_Inner
	enum_field     EnumAllowingAlias
	my_map         map[string]string
}

pub fn (o &Outer) pack() []byte {
	mut res := []byte{}
	// [packed=false]
	for _, x in o.inner_message {
		res << zzz_vproto_internal_pack_outer_inner(x, 2)
	}
	if o.enum_field != zzz_vproto_internal_new_enumallowingalias() {
		enum_field := zzz_vproto_internal_pack_enumallowingalias(o.enum_field, 3)
		res << enum_field
		unsafe {enum_field.free()}
	}
	for k, v in o.my_map {
		mut bytes := vproto.pack_string_field(k, 1)
		bytes << vproto.pack_string_field(v, 2)
		res << vproto.pack_bytes_field(bytes, 4)
	}
	return res
}

pub fn outer_unpack(buf []byte) ?Outer {
	mut res := zzz_vproto_internal_new_outer()
	mut total := 0
	for total < buf.len {
		mut i := 0
		buf_before_wire_type := buf[total..]
		tag_wiretype := vproto.unpack_tag_wire_type(buf_before_wire_type) or {
			return error('malformed protobuf (couldnt parse tag & wire type)')
		}
		cur_buf := buf_before_wire_type[tag_wiretype.consumed..]
		match tag_wiretype.tag {
			2 {
				// [packed=false]
				ii, v := zzz_vproto_internal_unpack_outer_inner(cur_buf, tag_wiretype.wire_type) ?
				res.inner_message << v
				i = ii
			}
			3 {
				ii, v := zzz_vproto_internal_unpack_enumallowingalias(cur_buf, tag_wiretype.wire_type) ?
				res.enum_field = v
				i = ii
			}
			4 {
				ii, bytes := vproto.unpack_message_field(cur_buf, tag_wiretype.wire_type) ?
				mut k := ''
				mut v := ''
				mut bytes_offset := 0
				for j := 0; j < 2; j++ {
					map_tag_wiretype := vproto.unpack_tag_wire_type(bytes[bytes_offset..]) or {
						return error('malformed protobuf (couldnt parse tag & wire type)')
					}
					bytes_offset += map_tag_wiretype.consumed
					match map_tag_wiretype.tag {
						1 {
							map_ii, kk := vproto.unpack_string_field(bytes[bytes_offset..],
								map_tag_wiretype.wire_type) ?
							bytes_offset += map_ii
							k = kk
						}
						2 {
							map_ii, vv := vproto.unpack_string_field(bytes[bytes_offset..],
								map_tag_wiretype.wire_type) ?
							bytes_offset += map_ii
							v = vv
						}
						else {
							return error('malformed map field (didnt unpack a key/value)')
						}
					}
				}
				res.my_map[k] = v
				i = ii
			}
			else {
				ii, v := vproto.unpack_unknown_field(cur_buf, tag_wiretype.wire_type)
				res.unknown_fields <<
					vproto.UnknownField{tag_wiretype.wire_type, tag_wiretype.tag, v}
				i = ii
			}
		}
		if i == 0 {
			return error('malformed protobuf (didnt unpack a field)')
		}
		total += tag_wiretype.consumed + i
	}
	return res
}

[inline]
pub fn (a Outer) eq(b Outer) bool {
	return true && a.inner_message.eq(b.inner_message) && a.enum_field == b.enum_field
}

[inline]
pub fn (a Outer) ne(b Outer) bool {
	return !a.eq(b)
}

[inline]
pub fn (a []Outer) eq(b []Outer) bool {
	if a.len != b.len {
		return false
	}
	for i, _ in a {
		if a[i].ne(b[i]) {
			return false
		}
	}
	return true
}

[inline]
pub fn (a []Outer) ne(b []Outer) bool {
	return !a.eq(b)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_new_outer() Outer {
	return Outer{}
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_pack_outer(o Outer, num u32) []byte {
	return vproto.pack_message_field(o.pack(), num)
}

// FOR INTERNAL USE ONLY
[inline]
pub fn zzz_vproto_internal_unpack_outer(buf []byte, tag_wiretype vproto.WireType) ?(int, Outer) {
	i, v := vproto.unpack_message_field(buf, tag_wiretype) ?
	mut unpacked := outer_unpack(v) ?
	return i, unpacked
}
